// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ae_publisher_user.proto

#ifndef PROTOBUF_ae_5fpublisher_5fuser_2eproto__INCLUDED
#define PROTOBUF_ae_5fpublisher_5fuser_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "num_types.pb.h"
// @@protoc_insertion_point(includes)

namespace rubicon {
namespace data {
namespace ad_engine {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ae_5fpublisher_5fuser_2eproto();
void protobuf_AssignDesc_ae_5fpublisher_5fuser_2eproto();
void protobuf_ShutdownFile_ae_5fpublisher_5fuser_2eproto();

class PublisherUser_PB;

// ===================================================================

class PublisherUser_PB : public ::google::protobuf::Message {
 public:
  PublisherUser_PB();
  virtual ~PublisherUser_PB();
  
  PublisherUser_PB(const PublisherUser_PB& from);
  
  inline PublisherUser_PB& operator=(const PublisherUser_PB& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PublisherUser_PB& default_instance();
  
  void Swap(PublisherUser_PB* other);
  
  // implements Message ----------------------------------------------
  
  PublisherUser_PB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PublisherUser_PB& from);
  void MergeFrom(const PublisherUser_PB& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string keywords = 1;
  inline int keywords_size() const;
  inline void clear_keywords();
  static const int kKeywordsFieldNumber = 1;
  inline const ::std::string& keywords(int index) const;
  inline ::std::string* mutable_keywords(int index);
  inline void set_keywords(int index, const ::std::string& value);
  inline void set_keywords(int index, const char* value);
  inline void set_keywords(int index, const char* value, size_t size);
  inline ::std::string* add_keywords();
  inline void add_keywords(const ::std::string& value);
  inline void add_keywords(const char* value);
  inline void add_keywords(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keywords() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keywords();
  
  // optional string gender = 2;
  inline bool has_gender() const;
  inline void clear_gender();
  static const int kGenderFieldNumber = 2;
  inline const ::std::string& gender() const;
  inline void set_gender(const ::std::string& value);
  inline void set_gender(const char* value);
  inline void set_gender(const char* value, size_t size);
  inline ::std::string* mutable_gender();
  inline ::std::string* release_gender();
  
  // optional .rubicon.data.common.AnUInt32_PB age = 3;
  inline bool has_age() const;
  inline void clear_age();
  static const int kAgeFieldNumber = 3;
  inline const ::rubicon::data::common::AnUInt32_PB& age() const;
  inline ::rubicon::data::common::AnUInt32_PB* mutable_age();
  inline ::rubicon::data::common::AnUInt32_PB* release_age();
  
  // optional .rubicon.data.common.AnUInt32_PB income = 4;
  inline bool has_income() const;
  inline void clear_income();
  static const int kIncomeFieldNumber = 4;
  inline const ::rubicon::data::common::AnUInt32_PB& income() const;
  inline ::rubicon::data::common::AnUInt32_PB* mutable_income();
  inline ::rubicon::data::common::AnUInt32_PB* release_income();
  
  // optional .rubicon.data.common.AnUInt32_PB children = 5;
  inline bool has_children() const;
  inline void clear_children();
  static const int kChildrenFieldNumber = 5;
  inline const ::rubicon::data::common::AnUInt32_PB& children() const;
  inline ::rubicon::data::common::AnUInt32_PB* mutable_children();
  inline ::rubicon::data::common::AnUInt32_PB* release_children();
  
  // optional .rubicon.data.common.AnUInt32_PB house_size = 6;
  inline bool has_house_size() const;
  inline void clear_house_size();
  static const int kHouseSizeFieldNumber = 6;
  inline const ::rubicon::data::common::AnUInt32_PB& house_size() const;
  inline ::rubicon::data::common::AnUInt32_PB* mutable_house_size();
  inline ::rubicon::data::common::AnUInt32_PB* release_house_size();
  
  // optional string ethnicity = 7;
  inline bool has_ethnicity() const;
  inline void clear_ethnicity();
  static const int kEthnicityFieldNumber = 7;
  inline const ::std::string& ethnicity() const;
  inline void set_ethnicity(const ::std::string& value);
  inline void set_ethnicity(const char* value);
  inline void set_ethnicity(const char* value, size_t size);
  inline ::std::string* mutable_ethnicity();
  inline ::std::string* release_ethnicity();
  
  // optional string education = 8;
  inline bool has_education() const;
  inline void clear_education();
  static const int kEducationFieldNumber = 8;
  inline const ::std::string& education() const;
  inline void set_education(const ::std::string& value);
  inline void set_education(const char* value);
  inline void set_education(const char* value, size_t size);
  inline ::std::string* mutable_education();
  inline ::std::string* release_education();
  
  // @@protoc_insertion_point(class_scope:rubicon.data.ad_engine.PublisherUser_PB)
 private:
  inline void set_has_gender();
  inline void clear_has_gender();
  inline void set_has_age();
  inline void clear_has_age();
  inline void set_has_income();
  inline void clear_has_income();
  inline void set_has_children();
  inline void clear_has_children();
  inline void set_has_house_size();
  inline void clear_has_house_size();
  inline void set_has_ethnicity();
  inline void clear_has_ethnicity();
  inline void set_has_education();
  inline void clear_has_education();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> keywords_;
  ::std::string* gender_;
  ::rubicon::data::common::AnUInt32_PB* age_;
  ::rubicon::data::common::AnUInt32_PB* income_;
  ::rubicon::data::common::AnUInt32_PB* children_;
  ::rubicon::data::common::AnUInt32_PB* house_size_;
  ::std::string* ethnicity_;
  ::std::string* education_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_ae_5fpublisher_5fuser_2eproto();
  friend void protobuf_AssignDesc_ae_5fpublisher_5fuser_2eproto();
  friend void protobuf_ShutdownFile_ae_5fpublisher_5fuser_2eproto();
  
  void InitAsDefaultInstance();
  static PublisherUser_PB* default_instance_;
};
// ===================================================================


// ===================================================================

// PublisherUser_PB

// repeated string keywords = 1;
inline int PublisherUser_PB::keywords_size() const {
  return keywords_.size();
}
inline void PublisherUser_PB::clear_keywords() {
  keywords_.Clear();
}
inline const ::std::string& PublisherUser_PB::keywords(int index) const {
  return keywords_.Get(index);
}
inline ::std::string* PublisherUser_PB::mutable_keywords(int index) {
  return keywords_.Mutable(index);
}
inline void PublisherUser_PB::set_keywords(int index, const ::std::string& value) {
  keywords_.Mutable(index)->assign(value);
}
inline void PublisherUser_PB::set_keywords(int index, const char* value) {
  keywords_.Mutable(index)->assign(value);
}
inline void PublisherUser_PB::set_keywords(int index, const char* value, size_t size) {
  keywords_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PublisherUser_PB::add_keywords() {
  return keywords_.Add();
}
inline void PublisherUser_PB::add_keywords(const ::std::string& value) {
  keywords_.Add()->assign(value);
}
inline void PublisherUser_PB::add_keywords(const char* value) {
  keywords_.Add()->assign(value);
}
inline void PublisherUser_PB::add_keywords(const char* value, size_t size) {
  keywords_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PublisherUser_PB::keywords() const {
  return keywords_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PublisherUser_PB::mutable_keywords() {
  return &keywords_;
}

// optional string gender = 2;
inline bool PublisherUser_PB::has_gender() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PublisherUser_PB::set_has_gender() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PublisherUser_PB::clear_has_gender() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PublisherUser_PB::clear_gender() {
  if (gender_ != &::google::protobuf::internal::kEmptyString) {
    gender_->clear();
  }
  clear_has_gender();
}
inline const ::std::string& PublisherUser_PB::gender() const {
  return *gender_;
}
inline void PublisherUser_PB::set_gender(const ::std::string& value) {
  set_has_gender();
  if (gender_ == &::google::protobuf::internal::kEmptyString) {
    gender_ = new ::std::string;
  }
  gender_->assign(value);
}
inline void PublisherUser_PB::set_gender(const char* value) {
  set_has_gender();
  if (gender_ == &::google::protobuf::internal::kEmptyString) {
    gender_ = new ::std::string;
  }
  gender_->assign(value);
}
inline void PublisherUser_PB::set_gender(const char* value, size_t size) {
  set_has_gender();
  if (gender_ == &::google::protobuf::internal::kEmptyString) {
    gender_ = new ::std::string;
  }
  gender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PublisherUser_PB::mutable_gender() {
  set_has_gender();
  if (gender_ == &::google::protobuf::internal::kEmptyString) {
    gender_ = new ::std::string;
  }
  return gender_;
}
inline ::std::string* PublisherUser_PB::release_gender() {
  clear_has_gender();
  if (gender_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gender_;
    gender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .rubicon.data.common.AnUInt32_PB age = 3;
inline bool PublisherUser_PB::has_age() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PublisherUser_PB::set_has_age() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PublisherUser_PB::clear_has_age() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PublisherUser_PB::clear_age() {
  if (age_ != NULL) age_->::rubicon::data::common::AnUInt32_PB::Clear();
  clear_has_age();
}
inline const ::rubicon::data::common::AnUInt32_PB& PublisherUser_PB::age() const {
  return age_ != NULL ? *age_ : *default_instance_->age_;
}
inline ::rubicon::data::common::AnUInt32_PB* PublisherUser_PB::mutable_age() {
  set_has_age();
  if (age_ == NULL) age_ = new ::rubicon::data::common::AnUInt32_PB;
  return age_;
}
inline ::rubicon::data::common::AnUInt32_PB* PublisherUser_PB::release_age() {
  clear_has_age();
  ::rubicon::data::common::AnUInt32_PB* temp = age_;
  age_ = NULL;
  return temp;
}

// optional .rubicon.data.common.AnUInt32_PB income = 4;
inline bool PublisherUser_PB::has_income() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PublisherUser_PB::set_has_income() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PublisherUser_PB::clear_has_income() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PublisherUser_PB::clear_income() {
  if (income_ != NULL) income_->::rubicon::data::common::AnUInt32_PB::Clear();
  clear_has_income();
}
inline const ::rubicon::data::common::AnUInt32_PB& PublisherUser_PB::income() const {
  return income_ != NULL ? *income_ : *default_instance_->income_;
}
inline ::rubicon::data::common::AnUInt32_PB* PublisherUser_PB::mutable_income() {
  set_has_income();
  if (income_ == NULL) income_ = new ::rubicon::data::common::AnUInt32_PB;
  return income_;
}
inline ::rubicon::data::common::AnUInt32_PB* PublisherUser_PB::release_income() {
  clear_has_income();
  ::rubicon::data::common::AnUInt32_PB* temp = income_;
  income_ = NULL;
  return temp;
}

// optional .rubicon.data.common.AnUInt32_PB children = 5;
inline bool PublisherUser_PB::has_children() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PublisherUser_PB::set_has_children() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PublisherUser_PB::clear_has_children() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PublisherUser_PB::clear_children() {
  if (children_ != NULL) children_->::rubicon::data::common::AnUInt32_PB::Clear();
  clear_has_children();
}
inline const ::rubicon::data::common::AnUInt32_PB& PublisherUser_PB::children() const {
  return children_ != NULL ? *children_ : *default_instance_->children_;
}
inline ::rubicon::data::common::AnUInt32_PB* PublisherUser_PB::mutable_children() {
  set_has_children();
  if (children_ == NULL) children_ = new ::rubicon::data::common::AnUInt32_PB;
  return children_;
}
inline ::rubicon::data::common::AnUInt32_PB* PublisherUser_PB::release_children() {
  clear_has_children();
  ::rubicon::data::common::AnUInt32_PB* temp = children_;
  children_ = NULL;
  return temp;
}

// optional .rubicon.data.common.AnUInt32_PB house_size = 6;
inline bool PublisherUser_PB::has_house_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PublisherUser_PB::set_has_house_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PublisherUser_PB::clear_has_house_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PublisherUser_PB::clear_house_size() {
  if (house_size_ != NULL) house_size_->::rubicon::data::common::AnUInt32_PB::Clear();
  clear_has_house_size();
}
inline const ::rubicon::data::common::AnUInt32_PB& PublisherUser_PB::house_size() const {
  return house_size_ != NULL ? *house_size_ : *default_instance_->house_size_;
}
inline ::rubicon::data::common::AnUInt32_PB* PublisherUser_PB::mutable_house_size() {
  set_has_house_size();
  if (house_size_ == NULL) house_size_ = new ::rubicon::data::common::AnUInt32_PB;
  return house_size_;
}
inline ::rubicon::data::common::AnUInt32_PB* PublisherUser_PB::release_house_size() {
  clear_has_house_size();
  ::rubicon::data::common::AnUInt32_PB* temp = house_size_;
  house_size_ = NULL;
  return temp;
}

// optional string ethnicity = 7;
inline bool PublisherUser_PB::has_ethnicity() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PublisherUser_PB::set_has_ethnicity() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PublisherUser_PB::clear_has_ethnicity() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PublisherUser_PB::clear_ethnicity() {
  if (ethnicity_ != &::google::protobuf::internal::kEmptyString) {
    ethnicity_->clear();
  }
  clear_has_ethnicity();
}
inline const ::std::string& PublisherUser_PB::ethnicity() const {
  return *ethnicity_;
}
inline void PublisherUser_PB::set_ethnicity(const ::std::string& value) {
  set_has_ethnicity();
  if (ethnicity_ == &::google::protobuf::internal::kEmptyString) {
    ethnicity_ = new ::std::string;
  }
  ethnicity_->assign(value);
}
inline void PublisherUser_PB::set_ethnicity(const char* value) {
  set_has_ethnicity();
  if (ethnicity_ == &::google::protobuf::internal::kEmptyString) {
    ethnicity_ = new ::std::string;
  }
  ethnicity_->assign(value);
}
inline void PublisherUser_PB::set_ethnicity(const char* value, size_t size) {
  set_has_ethnicity();
  if (ethnicity_ == &::google::protobuf::internal::kEmptyString) {
    ethnicity_ = new ::std::string;
  }
  ethnicity_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PublisherUser_PB::mutable_ethnicity() {
  set_has_ethnicity();
  if (ethnicity_ == &::google::protobuf::internal::kEmptyString) {
    ethnicity_ = new ::std::string;
  }
  return ethnicity_;
}
inline ::std::string* PublisherUser_PB::release_ethnicity() {
  clear_has_ethnicity();
  if (ethnicity_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ethnicity_;
    ethnicity_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string education = 8;
inline bool PublisherUser_PB::has_education() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PublisherUser_PB::set_has_education() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PublisherUser_PB::clear_has_education() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PublisherUser_PB::clear_education() {
  if (education_ != &::google::protobuf::internal::kEmptyString) {
    education_->clear();
  }
  clear_has_education();
}
inline const ::std::string& PublisherUser_PB::education() const {
  return *education_;
}
inline void PublisherUser_PB::set_education(const ::std::string& value) {
  set_has_education();
  if (education_ == &::google::protobuf::internal::kEmptyString) {
    education_ = new ::std::string;
  }
  education_->assign(value);
}
inline void PublisherUser_PB::set_education(const char* value) {
  set_has_education();
  if (education_ == &::google::protobuf::internal::kEmptyString) {
    education_ = new ::std::string;
  }
  education_->assign(value);
}
inline void PublisherUser_PB::set_education(const char* value, size_t size) {
  set_has_education();
  if (education_ == &::google::protobuf::internal::kEmptyString) {
    education_ = new ::std::string;
  }
  education_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PublisherUser_PB::mutable_education() {
  set_has_education();
  if (education_ == &::google::protobuf::internal::kEmptyString) {
    education_ = new ::std::string;
  }
  return education_;
}
inline ::std::string* PublisherUser_PB::release_education() {
  clear_has_education();
  if (education_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = education_;
    education_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ad_engine
}  // namespace data
}  // namespace rubicon

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ae_5fpublisher_5fuser_2eproto__INCLUDED
