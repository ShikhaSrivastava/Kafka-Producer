// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: event_bus.proto

#ifndef PROTOBUF_event_5fbus_2eproto__INCLUDED
#define PROTOBUF_event_5fbus_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace fim {
namespace eventbus {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_event_5fbus_2eproto();
void protobuf_AssignDesc_event_5fbus_2eproto();
void protobuf_ShutdownFile_event_5fbus_2eproto();

class EndPoint;
class EventBusMessage;
class SenderInfo_PB;
class HostInfo_PB;
class EventBusFeedback_PB;

enum Role_E {
  PROD = 1,
  DEV = 2,
  QA = 3,
  STAGING = 4,
  RESEARCH = 5
};
bool Role_E_IsValid(int value);
const Role_E Role_E_MIN = PROD;
const Role_E Role_E_MAX = RESEARCH;
const int Role_E_ARRAYSIZE = Role_E_MAX + 1;

const ::google::protobuf::EnumDescriptor* Role_E_descriptor();
inline const ::std::string& Role_E_Name(Role_E value) {
  return ::google::protobuf::internal::NameOfEnum(
    Role_E_descriptor(), value);
}
inline bool Role_E_Parse(
    const ::std::string& name, Role_E* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Role_E>(
    Role_E_descriptor(), name, value);
}
enum ListenerType_E {
  JOURNALLER = 1,
  STORM = 2,
  AD_HOC_LISTENER = 3,
  OTHER = 4
};
bool ListenerType_E_IsValid(int value);
const ListenerType_E ListenerType_E_MIN = JOURNALLER;
const ListenerType_E ListenerType_E_MAX = OTHER;
const int ListenerType_E_ARRAYSIZE = ListenerType_E_MAX + 1;

const ::google::protobuf::EnumDescriptor* ListenerType_E_descriptor();
inline const ::std::string& ListenerType_E_Name(ListenerType_E value) {
  return ::google::protobuf::internal::NameOfEnum(
    ListenerType_E_descriptor(), value);
}
inline bool ListenerType_E_Parse(
    const ::std::string& name, ListenerType_E* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ListenerType_E>(
    ListenerType_E_descriptor(), name, value);
}
// ===================================================================

class EndPoint : public ::google::protobuf::Message {
 public:
  EndPoint();
  virtual ~EndPoint();
  
  EndPoint(const EndPoint& from);
  
  inline EndPoint& operator=(const EndPoint& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EndPoint& default_instance();
  
  void Swap(EndPoint* other);
  
  // implements Message ----------------------------------------------
  
  EndPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EndPoint& from);
  void MergeFrom(const EndPoint& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional fixed32 addr = 2;
  inline bool has_addr() const;
  inline void clear_addr();
  static const int kAddrFieldNumber = 2;
  inline ::google::protobuf::uint32 addr() const;
  inline void set_addr(::google::protobuf::uint32 value);
  
  // optional uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:fim.eventbus.EndPoint)
 private:
  inline void set_has_addr();
  inline void clear_has_addr();
  inline void set_has_port();
  inline void clear_has_port();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 addr_;
  ::google::protobuf::uint32 port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_event_5fbus_2eproto();
  friend void protobuf_AssignDesc_event_5fbus_2eproto();
  friend void protobuf_ShutdownFile_event_5fbus_2eproto();
  
  void InitAsDefaultInstance();
  static EndPoint* default_instance_;
};
// -------------------------------------------------------------------

class EventBusMessage : public ::google::protobuf::Message {
 public:
  EventBusMessage();
  virtual ~EventBusMessage();
  
  EventBusMessage(const EventBusMessage& from);
  
  inline EventBusMessage& operator=(const EventBusMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EventBusMessage& default_instance();
  
  void Swap(EventBusMessage* other);
  
  // implements Message ----------------------------------------------
  
  EventBusMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventBusMessage& from);
  void MergeFrom(const EventBusMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes event = 2;
  inline bool has_event() const;
  inline void clear_event();
  static const int kEventFieldNumber = 2;
  inline const ::std::string& event() const;
  inline void set_event(const ::std::string& value);
  inline void set_event(const char* value);
  inline void set_event(const void* value, size_t size);
  inline ::std::string* mutable_event();
  inline ::std::string* release_event();
  
  // optional fixed64 sequence = 3;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 3;
  inline ::google::protobuf::uint64 sequence() const;
  inline void set_sequence(::google::protobuf::uint64 value);
  
  // optional uint32 pid = 4;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 4;
  inline ::google::protobuf::uint32 pid() const;
  inline void set_pid(::google::protobuf::uint32 value);
  
  // optional uint32 id = 5 [default = 0];
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 5;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // optional .fim.eventbus.EndPoint sender = 6;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 6;
  inline const ::fim::eventbus::EndPoint& sender() const;
  inline ::fim::eventbus::EndPoint* mutable_sender();
  inline ::fim::eventbus::EndPoint* release_sender();
  
  // optional bool is_valid = 7 [default = true];
  inline bool has_is_valid() const;
  inline void clear_is_valid();
  static const int kIsValidFieldNumber = 7;
  inline bool is_valid() const;
  inline void set_is_valid(bool value);
  
  // optional fixed64 emit_time_millis = 8 [default = 0];
  inline bool has_emit_time_millis() const;
  inline void clear_emit_time_millis();
  static const int kEmitTimeMillisFieldNumber = 8;
  inline ::google::protobuf::uint64 emit_time_millis() const;
  inline void set_emit_time_millis(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:fim.eventbus.EventBusMessage)
 private:
  inline void set_has_event();
  inline void clear_has_event();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_is_valid();
  inline void clear_has_is_valid();
  inline void set_has_emit_time_millis();
  inline void clear_has_emit_time_millis();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* event_;
  ::google::protobuf::uint64 sequence_;
  ::google::protobuf::uint32 pid_;
  ::google::protobuf::uint32 id_;
  ::fim::eventbus::EndPoint* sender_;
  ::google::protobuf::uint64 emit_time_millis_;
  bool is_valid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_event_5fbus_2eproto();
  friend void protobuf_AssignDesc_event_5fbus_2eproto();
  friend void protobuf_ShutdownFile_event_5fbus_2eproto();
  
  void InitAsDefaultInstance();
  static EventBusMessage* default_instance_;
};
// -------------------------------------------------------------------

class SenderInfo_PB : public ::google::protobuf::Message {
 public:
  SenderInfo_PB();
  virtual ~SenderInfo_PB();
  
  SenderInfo_PB(const SenderInfo_PB& from);
  
  inline SenderInfo_PB& operator=(const SenderInfo_PB& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SenderInfo_PB& default_instance();
  
  void Swap(SenderInfo_PB* other);
  
  // implements Message ----------------------------------------------
  
  SenderInfo_PB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SenderInfo_PB& from);
  void MergeFrom(const SenderInfo_PB& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 pid = 1;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 1;
  inline ::google::protobuf::uint32 pid() const;
  inline void set_pid(::google::protobuf::uint32 value);
  
  // required uint32 session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:fim.eventbus.SenderInfo_PB)
 private:
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 pid_;
  ::google::protobuf::uint32 session_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_event_5fbus_2eproto();
  friend void protobuf_AssignDesc_event_5fbus_2eproto();
  friend void protobuf_ShutdownFile_event_5fbus_2eproto();
  
  void InitAsDefaultInstance();
  static SenderInfo_PB* default_instance_;
};
// -------------------------------------------------------------------

class HostInfo_PB : public ::google::protobuf::Message {
 public:
  HostInfo_PB();
  virtual ~HostInfo_PB();
  
  HostInfo_PB(const HostInfo_PB& from);
  
  inline HostInfo_PB& operator=(const HostInfo_PB& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HostInfo_PB& default_instance();
  
  void Swap(HostInfo_PB* other);
  
  // implements Message ----------------------------------------------
  
  HostInfo_PB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HostInfo_PB& from);
  void MergeFrom(const HostInfo_PB& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed32 ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);
  
  // repeated .fim.eventbus.SenderInfo_PB sender = 2;
  inline int sender_size() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 2;
  inline const ::fim::eventbus::SenderInfo_PB& sender(int index) const;
  inline ::fim::eventbus::SenderInfo_PB* mutable_sender(int index);
  inline ::fim::eventbus::SenderInfo_PB* add_sender();
  inline const ::google::protobuf::RepeatedPtrField< ::fim::eventbus::SenderInfo_PB >&
      sender() const;
  inline ::google::protobuf::RepeatedPtrField< ::fim::eventbus::SenderInfo_PB >*
      mutable_sender();
  
  // @@protoc_insertion_point(class_scope:fim.eventbus.HostInfo_PB)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::fim::eventbus::SenderInfo_PB > sender_;
  ::google::protobuf::uint32 ip_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_event_5fbus_2eproto();
  friend void protobuf_AssignDesc_event_5fbus_2eproto();
  friend void protobuf_ShutdownFile_event_5fbus_2eproto();
  
  void InitAsDefaultInstance();
  static HostInfo_PB* default_instance_;
};
// -------------------------------------------------------------------

class EventBusFeedback_PB : public ::google::protobuf::Message {
 public:
  EventBusFeedback_PB();
  virtual ~EventBusFeedback_PB();
  
  EventBusFeedback_PB(const EventBusFeedback_PB& from);
  
  inline EventBusFeedback_PB& operator=(const EventBusFeedback_PB& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EventBusFeedback_PB& default_instance();
  
  void Swap(EventBusFeedback_PB* other);
  
  // implements Message ----------------------------------------------
  
  EventBusFeedback_PB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventBusFeedback_PB& from);
  void MergeFrom(const EventBusFeedback_PB& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .fim.eventbus.EndPoint multicast_channel = 1;
  inline bool has_multicast_channel() const;
  inline void clear_multicast_channel();
  static const int kMulticastChannelFieldNumber = 1;
  inline const ::fim::eventbus::EndPoint& multicast_channel() const;
  inline ::fim::eventbus::EndPoint* mutable_multicast_channel();
  inline ::fim::eventbus::EndPoint* release_multicast_channel();
  
  // required uint32 ip_addr = 2;
  inline bool has_ip_addr() const;
  inline void clear_ip_addr();
  static const int kIpAddrFieldNumber = 2;
  inline ::google::protobuf::uint32 ip_addr() const;
  inline void set_ip_addr(::google::protobuf::uint32 value);
  
  // required uint32 partition_count = 3;
  inline bool has_partition_count() const;
  inline void clear_partition_count();
  static const int kPartitionCountFieldNumber = 3;
  inline ::google::protobuf::uint32 partition_count() const;
  inline void set_partition_count(::google::protobuf::uint32 value);
  
  // required uint32 partition_index = 4;
  inline bool has_partition_index() const;
  inline void clear_partition_index();
  static const int kPartitionIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 partition_index() const;
  inline void set_partition_index(::google::protobuf::uint32 value);
  
  // optional .fim.eventbus.Role_E role = 5;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 5;
  inline fim::eventbus::Role_E role() const;
  inline void set_role(fim::eventbus::Role_E value);
  
  // optional .fim.eventbus.ListenerType_E type = 6;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 6;
  inline fim::eventbus::ListenerType_E type() const;
  inline void set_type(fim::eventbus::ListenerType_E value);
  
  // repeated .fim.eventbus.HostInfo_PB host = 7;
  inline int host_size() const;
  inline void clear_host();
  static const int kHostFieldNumber = 7;
  inline const ::fim::eventbus::HostInfo_PB& host(int index) const;
  inline ::fim::eventbus::HostInfo_PB* mutable_host(int index);
  inline ::fim::eventbus::HostInfo_PB* add_host();
  inline const ::google::protobuf::RepeatedPtrField< ::fim::eventbus::HostInfo_PB >&
      host() const;
  inline ::google::protobuf::RepeatedPtrField< ::fim::eventbus::HostInfo_PB >*
      mutable_host();
  
  // @@protoc_insertion_point(class_scope:fim.eventbus.EventBusFeedback_PB)
 private:
  inline void set_has_multicast_channel();
  inline void clear_has_multicast_channel();
  inline void set_has_ip_addr();
  inline void clear_has_ip_addr();
  inline void set_has_partition_count();
  inline void clear_has_partition_count();
  inline void set_has_partition_index();
  inline void clear_has_partition_index();
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::fim::eventbus::EndPoint* multicast_channel_;
  ::google::protobuf::uint32 ip_addr_;
  ::google::protobuf::uint32 partition_count_;
  ::google::protobuf::uint32 partition_index_;
  int role_;
  ::google::protobuf::RepeatedPtrField< ::fim::eventbus::HostInfo_PB > host_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_event_5fbus_2eproto();
  friend void protobuf_AssignDesc_event_5fbus_2eproto();
  friend void protobuf_ShutdownFile_event_5fbus_2eproto();
  
  void InitAsDefaultInstance();
  static EventBusFeedback_PB* default_instance_;
};
// ===================================================================


// ===================================================================

// EndPoint

// optional fixed32 addr = 2;
inline bool EndPoint::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EndPoint::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EndPoint::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EndPoint::clear_addr() {
  addr_ = 0u;
  clear_has_addr();
}
inline ::google::protobuf::uint32 EndPoint::addr() const {
  return addr_;
}
inline void EndPoint::set_addr(::google::protobuf::uint32 value) {
  set_has_addr();
  addr_ = value;
}

// optional uint32 port = 3;
inline bool EndPoint::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EndPoint::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EndPoint::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EndPoint::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 EndPoint::port() const {
  return port_;
}
inline void EndPoint::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// EventBusMessage

// required bytes event = 2;
inline bool EventBusMessage::has_event() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventBusMessage::set_has_event() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventBusMessage::clear_has_event() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventBusMessage::clear_event() {
  if (event_ != &::google::protobuf::internal::kEmptyString) {
    event_->clear();
  }
  clear_has_event();
}
inline const ::std::string& EventBusMessage::event() const {
  return *event_;
}
inline void EventBusMessage::set_event(const ::std::string& value) {
  set_has_event();
  if (event_ == &::google::protobuf::internal::kEmptyString) {
    event_ = new ::std::string;
  }
  event_->assign(value);
}
inline void EventBusMessage::set_event(const char* value) {
  set_has_event();
  if (event_ == &::google::protobuf::internal::kEmptyString) {
    event_ = new ::std::string;
  }
  event_->assign(value);
}
inline void EventBusMessage::set_event(const void* value, size_t size) {
  set_has_event();
  if (event_ == &::google::protobuf::internal::kEmptyString) {
    event_ = new ::std::string;
  }
  event_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EventBusMessage::mutable_event() {
  set_has_event();
  if (event_ == &::google::protobuf::internal::kEmptyString) {
    event_ = new ::std::string;
  }
  return event_;
}
inline ::std::string* EventBusMessage::release_event() {
  clear_has_event();
  if (event_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = event_;
    event_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional fixed64 sequence = 3;
inline bool EventBusMessage::has_sequence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EventBusMessage::set_has_sequence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EventBusMessage::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EventBusMessage::clear_sequence() {
  sequence_ = GOOGLE_ULONGLONG(0);
  clear_has_sequence();
}
inline ::google::protobuf::uint64 EventBusMessage::sequence() const {
  return sequence_;
}
inline void EventBusMessage::set_sequence(::google::protobuf::uint64 value) {
  set_has_sequence();
  sequence_ = value;
}

// optional uint32 pid = 4;
inline bool EventBusMessage::has_pid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EventBusMessage::set_has_pid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EventBusMessage::clear_has_pid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EventBusMessage::clear_pid() {
  pid_ = 0u;
  clear_has_pid();
}
inline ::google::protobuf::uint32 EventBusMessage::pid() const {
  return pid_;
}
inline void EventBusMessage::set_pid(::google::protobuf::uint32 value) {
  set_has_pid();
  pid_ = value;
}

// optional uint32 id = 5 [default = 0];
inline bool EventBusMessage::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EventBusMessage::set_has_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EventBusMessage::clear_has_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EventBusMessage::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 EventBusMessage::id() const {
  return id_;
}
inline void EventBusMessage::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional .fim.eventbus.EndPoint sender = 6;
inline bool EventBusMessage::has_sender() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EventBusMessage::set_has_sender() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EventBusMessage::clear_has_sender() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EventBusMessage::clear_sender() {
  if (sender_ != NULL) sender_->::fim::eventbus::EndPoint::Clear();
  clear_has_sender();
}
inline const ::fim::eventbus::EndPoint& EventBusMessage::sender() const {
  return sender_ != NULL ? *sender_ : *default_instance_->sender_;
}
inline ::fim::eventbus::EndPoint* EventBusMessage::mutable_sender() {
  set_has_sender();
  if (sender_ == NULL) sender_ = new ::fim::eventbus::EndPoint;
  return sender_;
}
inline ::fim::eventbus::EndPoint* EventBusMessage::release_sender() {
  clear_has_sender();
  ::fim::eventbus::EndPoint* temp = sender_;
  sender_ = NULL;
  return temp;
}

// optional bool is_valid = 7 [default = true];
inline bool EventBusMessage::has_is_valid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EventBusMessage::set_has_is_valid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EventBusMessage::clear_has_is_valid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EventBusMessage::clear_is_valid() {
  is_valid_ = true;
  clear_has_is_valid();
}
inline bool EventBusMessage::is_valid() const {
  return is_valid_;
}
inline void EventBusMessage::set_is_valid(bool value) {
  set_has_is_valid();
  is_valid_ = value;
}

// optional fixed64 emit_time_millis = 8 [default = 0];
inline bool EventBusMessage::has_emit_time_millis() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EventBusMessage::set_has_emit_time_millis() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EventBusMessage::clear_has_emit_time_millis() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EventBusMessage::clear_emit_time_millis() {
  emit_time_millis_ = GOOGLE_ULONGLONG(0);
  clear_has_emit_time_millis();
}
inline ::google::protobuf::uint64 EventBusMessage::emit_time_millis() const {
  return emit_time_millis_;
}
inline void EventBusMessage::set_emit_time_millis(::google::protobuf::uint64 value) {
  set_has_emit_time_millis();
  emit_time_millis_ = value;
}

// -------------------------------------------------------------------

// SenderInfo_PB

// required uint32 pid = 1;
inline bool SenderInfo_PB::has_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SenderInfo_PB::set_has_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SenderInfo_PB::clear_has_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SenderInfo_PB::clear_pid() {
  pid_ = 0u;
  clear_has_pid();
}
inline ::google::protobuf::uint32 SenderInfo_PB::pid() const {
  return pid_;
}
inline void SenderInfo_PB::set_pid(::google::protobuf::uint32 value) {
  set_has_pid();
  pid_ = value;
}

// required uint32 session_id = 2;
inline bool SenderInfo_PB::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SenderInfo_PB::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SenderInfo_PB::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SenderInfo_PB::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 SenderInfo_PB::session_id() const {
  return session_id_;
}
inline void SenderInfo_PB::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
}

// -------------------------------------------------------------------

// HostInfo_PB

// required fixed32 ip = 1;
inline bool HostInfo_PB::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HostInfo_PB::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HostInfo_PB::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HostInfo_PB::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 HostInfo_PB::ip() const {
  return ip_;
}
inline void HostInfo_PB::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// repeated .fim.eventbus.SenderInfo_PB sender = 2;
inline int HostInfo_PB::sender_size() const {
  return sender_.size();
}
inline void HostInfo_PB::clear_sender() {
  sender_.Clear();
}
inline const ::fim::eventbus::SenderInfo_PB& HostInfo_PB::sender(int index) const {
  return sender_.Get(index);
}
inline ::fim::eventbus::SenderInfo_PB* HostInfo_PB::mutable_sender(int index) {
  return sender_.Mutable(index);
}
inline ::fim::eventbus::SenderInfo_PB* HostInfo_PB::add_sender() {
  return sender_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fim::eventbus::SenderInfo_PB >&
HostInfo_PB::sender() const {
  return sender_;
}
inline ::google::protobuf::RepeatedPtrField< ::fim::eventbus::SenderInfo_PB >*
HostInfo_PB::mutable_sender() {
  return &sender_;
}

// -------------------------------------------------------------------

// EventBusFeedback_PB

// required .fim.eventbus.EndPoint multicast_channel = 1;
inline bool EventBusFeedback_PB::has_multicast_channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventBusFeedback_PB::set_has_multicast_channel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventBusFeedback_PB::clear_has_multicast_channel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventBusFeedback_PB::clear_multicast_channel() {
  if (multicast_channel_ != NULL) multicast_channel_->::fim::eventbus::EndPoint::Clear();
  clear_has_multicast_channel();
}
inline const ::fim::eventbus::EndPoint& EventBusFeedback_PB::multicast_channel() const {
  return multicast_channel_ != NULL ? *multicast_channel_ : *default_instance_->multicast_channel_;
}
inline ::fim::eventbus::EndPoint* EventBusFeedback_PB::mutable_multicast_channel() {
  set_has_multicast_channel();
  if (multicast_channel_ == NULL) multicast_channel_ = new ::fim::eventbus::EndPoint;
  return multicast_channel_;
}
inline ::fim::eventbus::EndPoint* EventBusFeedback_PB::release_multicast_channel() {
  clear_has_multicast_channel();
  ::fim::eventbus::EndPoint* temp = multicast_channel_;
  multicast_channel_ = NULL;
  return temp;
}

// required uint32 ip_addr = 2;
inline bool EventBusFeedback_PB::has_ip_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EventBusFeedback_PB::set_has_ip_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EventBusFeedback_PB::clear_has_ip_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EventBusFeedback_PB::clear_ip_addr() {
  ip_addr_ = 0u;
  clear_has_ip_addr();
}
inline ::google::protobuf::uint32 EventBusFeedback_PB::ip_addr() const {
  return ip_addr_;
}
inline void EventBusFeedback_PB::set_ip_addr(::google::protobuf::uint32 value) {
  set_has_ip_addr();
  ip_addr_ = value;
}

// required uint32 partition_count = 3;
inline bool EventBusFeedback_PB::has_partition_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EventBusFeedback_PB::set_has_partition_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EventBusFeedback_PB::clear_has_partition_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EventBusFeedback_PB::clear_partition_count() {
  partition_count_ = 0u;
  clear_has_partition_count();
}
inline ::google::protobuf::uint32 EventBusFeedback_PB::partition_count() const {
  return partition_count_;
}
inline void EventBusFeedback_PB::set_partition_count(::google::protobuf::uint32 value) {
  set_has_partition_count();
  partition_count_ = value;
}

// required uint32 partition_index = 4;
inline bool EventBusFeedback_PB::has_partition_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EventBusFeedback_PB::set_has_partition_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EventBusFeedback_PB::clear_has_partition_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EventBusFeedback_PB::clear_partition_index() {
  partition_index_ = 0u;
  clear_has_partition_index();
}
inline ::google::protobuf::uint32 EventBusFeedback_PB::partition_index() const {
  return partition_index_;
}
inline void EventBusFeedback_PB::set_partition_index(::google::protobuf::uint32 value) {
  set_has_partition_index();
  partition_index_ = value;
}

// optional .fim.eventbus.Role_E role = 5;
inline bool EventBusFeedback_PB::has_role() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EventBusFeedback_PB::set_has_role() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EventBusFeedback_PB::clear_has_role() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EventBusFeedback_PB::clear_role() {
  role_ = 1;
  clear_has_role();
}
inline fim::eventbus::Role_E EventBusFeedback_PB::role() const {
  return static_cast< fim::eventbus::Role_E >(role_);
}
inline void EventBusFeedback_PB::set_role(fim::eventbus::Role_E value) {
  GOOGLE_DCHECK(fim::eventbus::Role_E_IsValid(value));
  set_has_role();
  role_ = value;
}

// optional .fim.eventbus.ListenerType_E type = 6;
inline bool EventBusFeedback_PB::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EventBusFeedback_PB::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EventBusFeedback_PB::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EventBusFeedback_PB::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline fim::eventbus::ListenerType_E EventBusFeedback_PB::type() const {
  return static_cast< fim::eventbus::ListenerType_E >(type_);
}
inline void EventBusFeedback_PB::set_type(fim::eventbus::ListenerType_E value) {
  GOOGLE_DCHECK(fim::eventbus::ListenerType_E_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated .fim.eventbus.HostInfo_PB host = 7;
inline int EventBusFeedback_PB::host_size() const {
  return host_.size();
}
inline void EventBusFeedback_PB::clear_host() {
  host_.Clear();
}
inline const ::fim::eventbus::HostInfo_PB& EventBusFeedback_PB::host(int index) const {
  return host_.Get(index);
}
inline ::fim::eventbus::HostInfo_PB* EventBusFeedback_PB::mutable_host(int index) {
  return host_.Mutable(index);
}
inline ::fim::eventbus::HostInfo_PB* EventBusFeedback_PB::add_host() {
  return host_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fim::eventbus::HostInfo_PB >&
EventBusFeedback_PB::host() const {
  return host_;
}
inline ::google::protobuf::RepeatedPtrField< ::fim::eventbus::HostInfo_PB >*
EventBusFeedback_PB::mutable_host() {
  return &host_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace eventbus
}  // namespace fim

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< fim::eventbus::Role_E>() {
  return fim::eventbus::Role_E_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< fim::eventbus::ListenerType_E>() {
  return fim::eventbus::ListenerType_E_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_event_5fbus_2eproto__INCLUDED
